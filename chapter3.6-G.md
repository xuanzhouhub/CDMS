
# 3.6 图数据库查询处理


在[**3.1小节**](chapter3.1.md) 中我们讲授了数据管理系统的一般架构和模式，在本小节中我们将介绍图数据库中数据计算的实现方式。对于图数数据库来说，其数据计算通常为处理和执行图查询语句（如输入一条Cypher语句，图数据库执行该语句并得到相应的查询结果）。特殊的图数据库也支持复杂基于图的计算（如Tugraph支持复杂的图分析和图学习等等）。执行图查询语句的过程也称之为图查询处理，该过程由图查询引擎负责，其过程为将⽤户提交的图查询语句转换为具体的查询执⾏计划，经过一定的优化后，由存储引擎调用相应的数据来执行该查询计划，并最终得到查询结果。在本小节中，我们以 Neo4j 以及其声明式查询语⾔ Cypher 为例，介绍图数据库查询处理的具体流程。图分析和图学习的计算过程和图查询相似，只是计算过程更为复杂，本书不进行深入讲解。



## 3.6.1 图数据库的软件架构

在[**3.1小节**](chapter3.1.md) 中，我们讲授了数据管理系统的基本架构（图3.1）。图数据库遵从此框架，其架构如图3.13所示。



<center>
	<img src="fig/ch3.6-graph-arch.jpg" width="80%" alt="cypher-cycle" />
	<br>
	<div display: inline-block; padding : 2px>
		图 3.13-图数据库软件架构
	</div>
</center>









### 查询处理步骤
和关系数据库的查询处理类似，对于一个Cypher查询语句的查询处理分为三个步骤：查询解析、查询优化和查询执行，如图 3.6-1G 所示。
<center>
	<img src="fig/3.6-1-cypherCycle.png" width="100%" alt="cypher-cycle" />
	<br>
	<div display: inline-block; padding : 2px>
		图 3.6-1G Cypher语言查询处理步骤
	</div>
</center>

- 查询解析：将 Cypher 语句通过词法分析、语法分析和语义分析转化为一个抽象语法树（Abstract Syntax Tree）。⼀条 Cypher 语句最初表现为⼀个声明式查询字符串，它描述即将在数据库中匹配的图模式。
- 查询优化：语法树经过查询优化器（也称为计划器）⽣成逻辑计划，再转化为物理计划。查询优化的过程通常包含代数优化和物理优化。逻辑计划是一个高层次的查询表示，描述查询的基本操作步骤，由⼀系列表示查询语义的抽象操作符和逻辑操作符组成。物理计划描述查询具体的执⾏步骤和算法，包括选择的数据访问⽅法、连接算法等。
- 查询执行：执行生成的物理执行计划，由 Cypher 运行时完成。

接下来我们沿用关系数据库系统查询处理的例子来介绍Neo4j的查询处理过程以及Cypher的执行计划。
```SQL
[例3.6-1] 查询沐辰同学所选课程号以及课程成绩。
MATCH (mc:Student {Sname: '沐辰'})-[r:ENROLLS]->(c:Course)  
WITH mc, c, r  
RETURN c.Cno AS Cno, r.Grade AS Grade
```
当处理例3.6-1的Cypher语句时，Neo4j首先通过查询解析将该语句转化为一个抽象语法树，如图3.6-2G所示。在查询解析的步骤中，Neo4j首先通过词法分析将该查询字符串分解成一系列标记（tokens），如关键字、标识符、常量、操作符、分隔符等。然后通过语法分析构建语法树，在该过程中Neo4j会先依据上下文无关文法（Context-free Grammar）来生成具体语法树，再将其转化为抽象语法树，二者的区别在于，具体语法树会详细地还原查询语句中的所有细节，而抽象语法树则通过树结构本身隐式地表达一些内容，如括号、连接等等。最后，语义分析进⼀步验证顶点和边的依赖关系是否成⽴、是否正确使⽤属性等，增强语法树的语义表达和中间表示。语法分析和语义分析的区别在于语义分析在语法分析的基础上考虑了语句的逻辑性。

<center>
	<img src="fig/3.6-2-cypherExplaining.png" width="100%" alt="cypher-explain" />
	<br>
	<div display: inline-block; padding : 2px>
		图 3.6-2G 查询解析过程
	</div>
</center>


在完成查询解析后，查询优化器会将语法树转化为逻辑执行计划，并根据逻辑执行计划的结构和索引来生成多个物理执行计划，在当前例子中，我们并没有在数据中创建和指定索引。查询优化器会选择生成的最优计划来执行，并尝试所有可能的索引，选择执行时间最短的索引。在当前例子中Neo4j最终选择的查询计划如图3.6-3G所示，其中estimated rows表示当前运算符预计（产生）处理的行数，查询优化器会基于estimated rows来选择合适的执行计划；db hits表示当前运算符向Neo4j存储引擎请求的单位数量，一次数据库命中是存储引擎工作（检索或更新数据等操作）的一个抽象单位；rows表示当前运算符实际产生的数据行数量。首先系统需要通过Scan扫描找到查询的开始点，每个算子通常都包括多种执行方式，扫描操作包括AllNodesScan、NodeIndexSeek等，此处使用NodeByLabelScan来通过节点标签扫描开始点；Filter过滤将前一运算符得到的所有row进行断言，返回结果为true的行；Expand(All)对于给定的开始节点，根据关系中的模式沿开始节点展开；最后Projection投影将输入的每一行都按照要求输出需要的结果。


<center>
	<img src="fig/3.6-3-cypherQueryPlan.png" width="30%" alt="cypher- queryPlan" />
	<br>
	<div display: inline-block; padding : 2px>
		图 3.6-3G 查询计划
	</div>
</center>

[**上一页<<**](chapter3.5-D.md) | [**>>下一页**](chapter3.7-G.md)